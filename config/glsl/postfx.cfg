////////////////////////////////////////////////
//
// post effects
//
////////////////////////////////////////////////

fsvs = [result [
    attribute vec4 vvertex;
    @(screentexcoord 0)
    varying vec2 texcoord0;
    @arg2
    void main(void)
    {
        gl_Position = vvertex;   // woohoo, no mvp :) 
        texcoord0 = vtexcoord0; 
        @arg1
    }
]]

fsps = [result [
    uniform sampler2DRect tex0; 
    varying vec2 texcoord0;
    fragdata(0) vec4 fragcolor;
    @arg2
    void main(void)
    {
        vec4 color = texture2DRect(tex0, texcoord0);
        @arg1
    }
]]

fsvs4 = [
    fsvs [
        texcoord1 = vtexcoord0 + vec2(-1.5, -1.5);
        texcoord2 = vtexcoord0 + vec2( 1.5, -1.5);
        texcoord3 = vtexcoord0 + vec2(-1.5,  1.5);
        texcoord4 = vtexcoord0 + vec2( 1.5,  1.5);
        @arg1
    ] [
        varying vec2 texcoord1, texcoord2, texcoord3, texcoord4;
    ]
]

fsps4 = [
    fsps [
        vec4 s00 = texture2DRect(tex0, texcoord1);
        vec4 s02 = texture2DRect(tex0, texcoord2);
        vec4 s20 = texture2DRect(tex0, texcoord3);
        vec4 s22 = texture2DRect(tex0, texcoord4);
        @arg1
    ] [
        varying vec2 texcoord1, texcoord2, texcoord3, texcoord4;
    ]
]

// some simple ones that just do an effect on the RGB value...

lazyshader 0 "invert" (fsvs) (fsps [fragcolor = 1.0 - color;])
lazyshader 0 "gbr"    (fsvs) (fsps [fragcolor = color.yzxw;])
lazyshader 0 "bw"     (fsvs) (fsps [fragcolor = vec4(dot(color.xyz, vec3(0.333)));])

// sobel

lazyshader 0 "sobel" (fsvs4) (fsps4 [
    vec4 t = s00 + s20 - s02 - s22;
    vec4 u = s00 + s02 - s20 - s22;
    fragcolor = color + t*t + u*u;
])

// rotoscope

lazyshader 0 "rotoscope" [
    attribute vec4 vvertex;
    @(screentexcoord 0)
    uniform vec4 params;
    varying vec2 t11, t00, t12, t01, t20, t02, t21, t10, t22;
    void main(void)
    {
        gl_Position = vvertex;
        t11 = vtexcoord0;
        t00 = vec2(-1.0, -1.0)*params.x + vtexcoord0;
        t12 = vec2( 0.0,  1.0)*params.x + vtexcoord0;
        t01 = vec2(-1.0,  0.0)*params.x + vtexcoord0;
        t20 = vec2( 1.0, -1.0)*params.x + vtexcoord0;
        t02 = vec2(-1.0,  1.0)*params.x + vtexcoord0;
        t21 = vec2( 1.0,  0.0)*params.x + vtexcoord0;
        t10 = vec2( 0.0, -1.0)*params.x + vtexcoord0;
        t22 = vec2( 1.0,  1.0)*params.x + vtexcoord0;
    }
] [
    uniform sampler2DRect tex0; 
    varying vec2 t11, t00, t12, t01, t20, t02, t21, t10, t22;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        vec4 c00 = texture2DRect(tex0, t00);
        vec4 c01 = texture2DRect(tex0, t01);
        vec4 c02 = texture2DRect(tex0, t02);
        vec4 c10 = texture2DRect(tex0, t10);
        vec4 c11 = texture2DRect(tex0, t11);
        vec4 c12 = texture2DRect(tex0, t12);
        vec4 c20 = texture2DRect(tex0, t20);
        vec4 c21 = texture2DRect(tex0, t21);
        vec4 c22 = texture2DRect(tex0, t22);

        vec4 diag1 = c00 - c22;
        vec4 diag2 = c02 - c20;
        vec4 xedge = (c01 - c21)*2.0 + diag1 + diag2;
        vec4 yedge = (c10 - c12)*2.0 + diag1 - diag2;
        xedge *= xedge;
        yedge *= yedge;

        vec4 xyedge = xedge + yedge;
        float sobel = step(max(xyedge.x, max(xyedge.y, xyedge.z)), 0.1);

        float hue = dot(c11.xyz, vec3(1.0));
        c11 /= hue;
        vec3 cc = step(vec3(0.2, 0.8, 1.5), vec3(hue));
        c11 *= dot(cc, vec3(0.5, 0.5, 1.5)); 

        fragcolor = c11 * max(cc.z, sobel);

    }
]

blur3shader = [
    lazyshader 0 $arg1 [
        attribute vec4 vvertex;
        @(screentexcoord 0)
        varying vec2 texcoord0, texcoord1;
        void main(void)
        {
            gl_Position = vvertex;
            texcoord0 = vtexcoord0 + vec2(@(? $arg2 -0.5 0.0), @(? $arg3 -0.5 0.0));
            texcoord1 = vtexcoord0 + vec2(@(? $arg2  0.5 0.0), @(? $arg3  0.5 0.0));
        }
    ] [
        uniform sampler2DRect tex0; 
        varying vec2 texcoord0, texcoord1;
        fragdata(0) vec4 fragcolor;
        void main(void)
        {
            fragcolor = 0.5*(texture2DRect(tex0, texcoord0) + texture2DRect(tex0, texcoord1));
        }
    ]
]
blur3shader hblur3 1 0
blur3shader vblur3 0 1

blur5shader = [
    lazyshader 0 $arg1 [
        attribute vec4 vvertex;
        @(screentexcoord 0)
        varying vec2 texcoord0, texcoord1, texcoord2;
        void main(void)
        {
            gl_Position = vvertex;
            texcoord0 = vtexcoord0;
            texcoord1 = vtexcoord0 + vec2(@(? $arg2 -1.333 0.0), @(? $arg3 -1.333 0.0));
            texcoord2 = vtexcoord0 + vec2(@(? $arg2  1.333 0.0), @(? $arg3  1.333 0.0));
        }
    ] [
        uniform sampler2DRect tex0; 
        varying vec2 texcoord0, texcoord1, texcoord2;
        fragdata(0) vec4 fragcolor;
        void main(void)
        {
            fragcolor = 0.4*texture2DRect(tex0, texcoord0) + 0.3*(texture2DRect(tex0, texcoord1) + texture2DRect(tex0, texcoord2));
        }
    ]
]
blur5shader hblur5 1 0
blur5shader vblur5 0 1

rotoscope = [
    clearpostfx
    if $numargs [
        addpostfx rotoscope 0 0 0 $arg1
        case $arg2 1  [ addpostfx blur3 ] 2 [ addpostfx blur5 ]
    ]
]

shader 0 "scope" [
    attribute vec4 vvertex;
    uniform vec4 params;
    uniform vec4 screentexcoord0;
    varying vec2 texcoord[9];
    varying vec2 fragCoord;

    #define vtexcoord0 (vvertex.xy * screentexcoord0.xy + screentexcoord0.zw)

    void main(void)
    {
        gl_Position = vvertex;
        fragCoord = vtexcoord0;
        const int Zoom_Sight = 1;
        const int Zoom_Scope = 2;
        vec2 offset[8];
        if (params.x == Zoom_Sight)
        {
            offset[0] = vec2(-5.0f,  0.0f);
            offset[1] = vec2(5.0f,  0.0f);
            offset[2] = vec2(0.0f, -5.0f);
            offset[3] = vec2(0.0f,  5.0f);
            offset[4] = vec2(-2.0f, -2.0f);
            offset[5] = vec2(2.0f, -2.0f);
            offset[6] = vec2(-2.0f,  2.0f);
            offset[7] = vec2(2.0f,  2.0f);
        }
        else if (params.x == Zoom_Scope)
        {
            offset[0] = vec2(-2.5f,  0.0f);
            offset[1] = vec2(2.5f,  0.0f);
            offset[2] = vec2( 0.0f, -2.5f);
            offset[3] = vec2(0.0f,  2.5f);
            offset[4] = vec2(-1.0f, -1.0f);
            offset[5] = vec2(1.0f, -1.0f);
            offset[6] = vec2(-1.0f,  1.0f);
            offset[7] = vec2(1.0f,  1.0f);
        }
        texcoord[0] = vtexcoord0;
        for (int i = 0; i < 8; i++)
        {
            texcoord[i+1] = vtexcoord0 + offset[i];
        }
    }
] [
    uniform vec4 params;
    uniform sampler2DRect tex0;
    uniform vec4 viewsize;
    varying vec2 texcoord[9];
    varying vec2 fragCoord;
    fragdata(0) vec4 fragcolor;

    const float weights[9] = float[]
    (
        0.260f,
        0.055f, 0.055f, 0.055f, 0.055f,
        0.130f, 0.130f, 0.130f, 0.130f
    );

    float random(vec2 coord)
    {
        return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453);
    }

    void main(void)
    {
        const int Zoom_Sight = 1;
        const int Zoom_Scope = 2;
        if (params.x == Zoom_Sight)
        {
            vec2 screenCenter = viewsize.xy * 0.5f;
            float radius = length(fragCoord - screenCenter) / length(viewsize.xy * 0.5f);
            radius *= params.y;
            float vignette = (1.0f - smoothstep(0.6f * params.x, 1.0f, radius));
            vec4 blurColor = vec4(0.0f);
            for (int i = 0; i < 9; i++)
            {
                blurColor += weights[i] * texture2DRect(tex0, texcoord[i]);
            }
            vec4 originalColor = texture2DRect(tex0, fragCoord);
            float centerWeight = smoothstep(0.0f, 0.6f * params.x, radius);
            fragcolor = mix(originalColor, blurColor, centerWeight) * vignette;
        }
        else if (params.x == Zoom_Scope)
        {
            vec2 screenCenter = viewsize.xy * 0.5f;
            vec2 toCenter = fragCoord - screenCenter;
            float radius = length(toCenter) / length(viewsize.xy * 0.5f);
            radius *= params.y;
            float vignette = 1.0f - smoothstep(0.1f, 0.5f, radius);
            float distortionStrength = smoothstep(0.2f, 0.5f, radius) * 0.2f;
            vec2 distortedCoord = screenCenter + normalize(toCenter) * (1.0f + distortionStrength) * length(toCenter);
            float refractionStrength = mix(0.08f, 0.3f, smoothstep(0.1f, 0.5f, radius));
            float noiseFactor = (random(fragCoord) - 0.5f) * 0.01f;
            vec2 refractedCoord = mix(fragCoord, distortedCoord, smoothstep(0.2f, 0.6f, radius));
            refractedCoord += (toCenter * pow(radius, 2.0f) * refractionStrength) + toCenter * noiseFactor;
            vec4 refractedColor = texture2DRect(tex0, refractedCoord);
            vec4 blurColor = vec4(0.0);
            for (int i = 0; i < 9; i++)
            {
                vec2 refCoord = texcoord[i] + (toCenter * pow(radius, 2.0f) * refractionStrength) + toCenter * noiseFactor;
                blurColor += weights[i] * texture2DRect(tex0, refCoord);
            }
            vec4 originalColor = texture2DRect(tex0, refractedCoord);
            float centerWeight = smoothstep(0.0f, 0.2f, radius);
            vec4 finalColor = mix(originalColor, blurColor, centerWeight);
            fragcolor = mix(finalColor, refractedColor, 0.9f) * vignette;
        }
    }
]

shader 0 "underwater" [
    attribute vec4 vvertex;
    uniform vec4 screentexcoord0;
    varying vec2 fragCoord;

    #define vtexcoord0 (vvertex.xy * screentexcoord0.xy + screentexcoord0.zw)

    void main(void)
    {
        gl_Position = vvertex;
        fragCoord = vtexcoord0;
    }
] [
    uniform vec4 params;
    uniform sampler2DRect tex0;
    uniform vec4 viewsize;
    varying vec2 fragCoord;
    fragdata(0) vec4 fragcolor;

    float random(vec2 coord)
    {
        return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453);
    }

    void main(void)
    {
        vec2 screenCenter = viewsize.xy * 0.5f;
        vec2 toCenter = fragCoord - screenCenter;
        float maxDist = length(viewsize.xy * 0.5f);
        float radius = length(toCenter) / maxDist;
        float time = params.x / max(params.y, 1.0f);
        vec2 wobbleOffset = vec2(
            sin(time * 10.0f + fragCoord.y * 0.05f) * 5.0f,
            cos(time * 8.0f + fragCoord.x * 0.05f) * 5.0f
        );
        vec2 distortedCoord = fragCoord + wobbleOffset;
        vec4 scene = texture2DRect(tex0, distortedCoord);
        fragcolor = scene;
    }
]

shader 0 "evt_fade_black" [
    attribute vec4 vvertex;
    uniform vec4 screentexcoord0;
    varying vec2 fragCoord;

    #define vtexcoord0 (vvertex.xy * screentexcoord0.xy + screentexcoord0.zw)

    void main(void)
    {
        gl_Position = vvertex;
        fragCoord = vtexcoord0;
    }
] [
    uniform vec4 params;
    uniform sampler2DRect tex0;
    varying vec2 fragCoord;
    fragdata(0) vec4 fragcolor;

    void main(void)
    {
        vec4 scene = texture2DRect(tex0, fragCoord);
        float progress = clamp(params.x / max(params.y, 1.0f), 0.0f, 1.0f);
        float direction = (params.z < 0) ? (1.0f - progress) : progress;
        fragcolor = vec4(scene.rgb * direction, scene.a);
    }
]

shader 0 "evt_teleport" [
    attribute vec4 vvertex;
    uniform vec4 screentexcoord0;
    varying vec2 fragCoord;

    #define vtexcoord0 (vvertex.xy * screentexcoord0.xy + screentexcoord0.zw)

    void main(void)
    {
        gl_Position = vvertex;
        fragCoord = vtexcoord0;
    }
] [
    uniform vec4 params;
    uniform sampler2DRect tex0;
    uniform vec4 viewsize;
    varying vec2 fragCoord;
    fragdata(0) vec4 fragcolor;

    float random(vec2 coord)
    {
        return fract(sin(dot(coord.xy, vec2(26.9898, 78.233))) * 43758.5453);
    }

    void main(void)
    {
        vec2 screenCenter = viewsize.xy * 0.5f;
        vec2 toCenter = fragCoord - screenCenter;
        float maxDist = length(viewsize.xy * 0.5f);
        float radius = length(toCenter) / maxDist;
        float progress = clamp(params.x / max(params.y, 1.0f), 0.0f, 1.0f);
        float direction = (params.z < 0) ? (1.0f - progress) : progress;
        float wobbleStrength = 15.0f * direction;
        float wobbleFrequency = 20.0f;
        float randomX = random(fragCoord + params.x * 5.0f) * 2.0f - 1.0f;
        float randomY = random(fragCoord - params.x * 5.0f) * 2.0f - 1.0f;
        vec2 wobbleOffset = vec2(
            sin(params.x * wobbleFrequency + fragCoord.y * 0.1f) * wobbleStrength + randomX * wobbleStrength,
            cos(params.x * wobbleFrequency + fragCoord.x * 0.1f) * wobbleStrength + randomY * wobbleStrength
        );
        vec2 distortedCoord = fragCoord + wobbleOffset;
        vec4 scene = texture2DRect(tex0, distortedCoord);
        float whiteIntensity = mix(0.5f, 1.0f, direction);
        vec3 fadedColor = mix(scene.rgb, vec3(1.0f) * whiteIntensity, direction);
        fragcolor = vec4(fadedColor, scene.a);
    }
]

shader 0 "evt_spawn" [
    attribute vec4 vvertex;
    uniform vec4 screentexcoord0;
    varying vec2 fragCoord;

    #define vtexcoord0 (vvertex.xy * screentexcoord0.xy + screentexcoord0.zw)

    void main(void)
    {
        gl_Position = vvertex;
        fragCoord = vtexcoord0;
    }
] [
    uniform vec4 params;
    uniform sampler2DRect tex0;
    uniform vec4 viewsize;
    varying vec2 fragCoord;
    fragdata(0) vec4 fragcolor;

    float random(vec2 coord)
    {
        return fract(sin(dot(coord.xy, vec2(26.9898, 78.233))) * 43758.5453);
    }

    void main(void)
    {
        vec2 screenCenter = viewsize.xy * 0.5f;
        vec2 toCenter = fragCoord - screenCenter;
        float maxDist = length(viewsize.xy * 0.5f);
        float radius = length(toCenter) / maxDist;
        float progress = clamp(params.x / max(params.y, 1.0f), 0.0f, 1.0f);
        float direction = (params.z < 0) ? (1.0f - progress) : progress;
        float wobbleStrength = 10.0f * direction;
        float wobbleFrequency = 50.0f;
        float randomX = random(fragCoord + params.x * 5.0f) * 2.0f - 1.0f;
        float randomY = random(fragCoord - params.x * 5.0f) * 2.0f - 1.0f;
        vec2 wobbleOffset = vec2(
            sin(params.x * wobbleFrequency + fragCoord.y * 0.1f) * wobbleStrength + randomX * wobbleStrength,
            cos(params.x * wobbleFrequency + fragCoord.x * 0.1f) * wobbleStrength + randomY * wobbleStrength
        );
        vec2 distortedCoord = fragCoord + wobbleOffset;
        vec4 scene = texture2DRect(tex0, distortedCoord);
        vec3 inverted = vec3(1.0f) - scene.rgb;
        vec3 result = mix(scene.rgb, inverted, direction);
        fragcolor = vec4(result, scene.a);
    }
]

shader 0 "evt_pickup" [
    attribute vec4 vvertex;
    uniform vec4 screentexcoord0;
    varying vec2 fragCoord;

    #define vtexcoord0 (vvertex.xy * screentexcoord0.xy + screentexcoord0.zw)

    void main(void)
    {
        gl_Position = vvertex;
        fragCoord = vtexcoord0;
    }
] [
    uniform vec4 params;
    uniform sampler2DRect tex0;
    uniform vec4 viewsize;
    varying vec2 fragCoord;
    fragdata(0) vec4 fragcolor;

    void main(void)
    {
        vec4 scene = texture2DRect(tex0, fragCoord);
        vec2 screenCenter = viewsize.xy * 0.5f;
        float maxDist = length(viewsize.xy * 0.5f);
        float radius = length(fragCoord - screenCenter) / maxDist;
        float progress = clamp(params.x / max(params.y, 1.0f), 0.0f, 1.0f);
        float vignetteRadius = mix(0.0f, 1.0f, progress);
        float fadeMultiplier = (params.z < 0) ? 1.5f : 1.0f;
        float vignetteFade = (params.z < 0) ? (1.0f - progress) : progress;
        float vignetteSoftness = (params.z < 0) ? 0.35f : 0.5f;
        float vignette = smoothstep(vignetteRadius - vignetteSoftness, vignetteRadius, radius);
        vec3 vignetteColor = vec3(1.0f);
        float vignetteOpacity = params.w * fadeMultiplier;
        vec3 blendedColor = mix(scene.rgb, vignetteColor, vignette * vignetteFade * vignetteOpacity);
        fragcolor = vec4(blendedColor, scene.a);
    }
]
