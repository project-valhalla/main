////////////////////////////////////////////////
//
// post effects
//
////////////////////////////////////////////////

fsvs = [result [
    attribute vec4 vvertex;
    @(screentexcoord 0)
    varying vec2 texcoord0;
    @arg2
    void main(void)
    {
        gl_Position = vvertex;   // woohoo, no mvp :) 
        texcoord0 = vtexcoord0; 
        @arg1
    }
]]

fsps = [result [
    uniform sampler2DRect tex0; 
    varying vec2 texcoord0;
    fragdata(0) vec4 fragcolor;
    @arg2
    void main(void)
    {
        vec4 color = texture2DRect(tex0, texcoord0);
        @arg1
    }
]]

fsvs4 = [
    fsvs [
        texcoord1 = vtexcoord0 + vec2(-1.5, -1.5);
        texcoord2 = vtexcoord0 + vec2( 1.5, -1.5);
        texcoord3 = vtexcoord0 + vec2(-1.5,  1.5);
        texcoord4 = vtexcoord0 + vec2( 1.5,  1.5);
        @arg1
    ] [
        varying vec2 texcoord1, texcoord2, texcoord3, texcoord4;
    ]
]

fsps4 = [
    fsps [
        vec4 s00 = texture2DRect(tex0, texcoord1);
        vec4 s02 = texture2DRect(tex0, texcoord2);
        vec4 s20 = texture2DRect(tex0, texcoord3);
        vec4 s22 = texture2DRect(tex0, texcoord4);
        @arg1
    ] [
        varying vec2 texcoord1, texcoord2, texcoord3, texcoord4;
    ]
]

// some simple ones that just do an effect on the RGB value...

lazyshader 0 "invert" (fsvs) (fsps [fragcolor = 1.0 - color;])
lazyshader 0 "gbr"    (fsvs) (fsps [fragcolor = color.yzxw;])
lazyshader 0 "bw"     (fsvs) (fsps [fragcolor = vec4(dot(color.xyz, vec3(0.333)));])

// sobel

lazyshader 0 "sobel" (fsvs4) (fsps4 [
    vec4 t = s00 + s20 - s02 - s22;
    vec4 u = s00 + s02 - s20 - s22;
    fragcolor = color + t*t + u*u;
])

// rotoscope

lazyshader 0 "rotoscope" [
    attribute vec4 vvertex;
    @(screentexcoord 0)
    uniform vec4 params;
    varying vec2 t11, t00, t12, t01, t20, t02, t21, t10, t22;
    void main(void)
    {
        gl_Position = vvertex;
        t11 = vtexcoord0;
        t00 = vec2(-1.0, -1.0)*params.x + vtexcoord0;
        t12 = vec2( 0.0,  1.0)*params.x + vtexcoord0;
        t01 = vec2(-1.0,  0.0)*params.x + vtexcoord0;
        t20 = vec2( 1.0, -1.0)*params.x + vtexcoord0;
        t02 = vec2(-1.0,  1.0)*params.x + vtexcoord0;
        t21 = vec2( 1.0,  0.0)*params.x + vtexcoord0;
        t10 = vec2( 0.0, -1.0)*params.x + vtexcoord0;
        t22 = vec2( 1.0,  1.0)*params.x + vtexcoord0;
    }
] [
    uniform sampler2DRect tex0; 
    varying vec2 t11, t00, t12, t01, t20, t02, t21, t10, t22;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        vec4 c00 = texture2DRect(tex0, t00);
        vec4 c01 = texture2DRect(tex0, t01);
        vec4 c02 = texture2DRect(tex0, t02);
        vec4 c10 = texture2DRect(tex0, t10);
        vec4 c11 = texture2DRect(tex0, t11);
        vec4 c12 = texture2DRect(tex0, t12);
        vec4 c20 = texture2DRect(tex0, t20);
        vec4 c21 = texture2DRect(tex0, t21);
        vec4 c22 = texture2DRect(tex0, t22);

        vec4 diag1 = c00 - c22;
        vec4 diag2 = c02 - c20;
        vec4 xedge = (c01 - c21)*2.0 + diag1 + diag2;
        vec4 yedge = (c10 - c12)*2.0 + diag1 - diag2;
        xedge *= xedge;
        yedge *= yedge;

        vec4 xyedge = xedge + yedge;
        float sobel = step(max(xyedge.x, max(xyedge.y, xyedge.z)), 0.1);

        float hue = dot(c11.xyz, vec3(1.0));
        c11 /= hue;
        vec3 cc = step(vec3(0.2, 0.8, 1.5), vec3(hue));
        c11 *= dot(cc, vec3(0.5, 0.5, 1.5)); 

        fragcolor = c11 * max(cc.z, sobel);

    }
]

blur3shader = [
    lazyshader 0 $arg1 [
        attribute vec4 vvertex;
        @(screentexcoord 0)
        varying vec2 texcoord0, texcoord1;
        void main(void)
        {
            gl_Position = vvertex;
            texcoord0 = vtexcoord0 + vec2(@(? $arg2 -0.5 0.0), @(? $arg3 -0.5 0.0));
            texcoord1 = vtexcoord0 + vec2(@(? $arg2  0.5 0.0), @(? $arg3  0.5 0.0));
        }
    ] [
        uniform sampler2DRect tex0; 
        varying vec2 texcoord0, texcoord1;
        fragdata(0) vec4 fragcolor;
        void main(void)
        {
            fragcolor = 0.5*(texture2DRect(tex0, texcoord0) + texture2DRect(tex0, texcoord1));
        }
    ]
]
blur3shader hblur3 1 0
blur3shader vblur3 0 1

blur5shader = [
    lazyshader 0 $arg1 [
        attribute vec4 vvertex;
        @(screentexcoord 0)
        varying vec2 texcoord0, texcoord1, texcoord2;
        void main(void)
        {
            gl_Position = vvertex;
            texcoord0 = vtexcoord0;
            texcoord1 = vtexcoord0 + vec2(@(? $arg2 -1.333 0.0), @(? $arg3 -1.333 0.0));
            texcoord2 = vtexcoord0 + vec2(@(? $arg2  1.333 0.0), @(? $arg3  1.333 0.0));
        }
    ] [
        uniform sampler2DRect tex0; 
        varying vec2 texcoord0, texcoord1, texcoord2;
        fragdata(0) vec4 fragcolor;
        void main(void)
        {
            fragcolor = 0.4*texture2DRect(tex0, texcoord0) + 0.3*(texture2DRect(tex0, texcoord1) + texture2DRect(tex0, texcoord2));
        }
    ]
]
blur5shader hblur5 1 0
blur5shader vblur5 0 1

rotoscope = [
    clearpostfx
    if $numargs [
        addpostfx rotoscope 0 0 0 $arg1
        case $arg2 1  [ addpostfx blur3 ] 2 [ addpostfx blur5 ]
    ]
]

lazyshader 0 "saturation" [
    attribute vec4 vvertex;
    @(screentexcoord 0)
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0;
    }
] [
    uniform vec4 params;
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    fragdata(0) vec4 fragcolor;

    void main(void)
    {
        vec4 color = texture2DRect(tex0, texcoord0);
        float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));
        float saturation = params.w;
        vec3 saturatedColor = mix(vec3(luminance), color.rgb, saturation);
        fragcolor = vec4(saturatedColor, 1.0);
    }
]

shader 0 "vignette" [
    attribute vec4 vvertex;
    uniform vec4 screentexcoord0;
    varying vec2 fragCoord;

    #define vtexcoord0 (vvertex.xy * screentexcoord0.xy + screentexcoord0.zw)

    void main(void)
    {
        gl_Position = vvertex;
        fragCoord = vtexcoord0;
    }
] [
    uniform sampler2DRect tex0;
    uniform vec4 viewsize;
    varying vec2 fragCoord;
    fragdata(0) vec4 fragcolor;

    void main(void)
    {
        vec2 screenCenter = viewsize.xy * 0.5;
        vec2 aspectRatio = vec2(viewsize.x / viewsize.y, 1.0); 
        vec2 normalizedFragCoord = (fragCoord - screenCenter) / (viewsize.xy * 0.5);
        normalizedFragCoord *= aspectRatio;
        float radius = length(normalizedFragCoord);
        float vignette = 1.0 - smoothstep(0.5, 1.2, radius);
        vignette = mix(1.0, vignette, 0.35);
        vec4 originalColor = texture2DRect(tex0, fragCoord);
        fragcolor = originalColor * vignette;
    }
]

shader 0 "scope" [
    attribute vec4 vvertex;
    uniform vec4 params;
    uniform vec4 screentexcoord0;
    varying vec2 texcoord[9];
    varying vec2 fragCoord;

    #define vtexcoord0 (vvertex.xy * screentexcoord0.xy + screentexcoord0.zw)

    void main(void)
    {
        gl_Position = vvertex;
        fragCoord = vtexcoord0;
        const int Zoom_Sight = 1;
        const int Zoom_Scope = 2;
        vec2 offset[8];
        if (params.x == Zoom_Sight)
        {
            offset[0] = vec2(-5.0,  0.0);
            offset[1] = vec2( 5.0,  0.0);
            offset[2] = vec2( 0.0, -5.0);
            offset[3] = vec2( 0.0,  5.0);
            offset[4] = vec2(-2.0,  2.0);
            offset[5] = vec2( 2.0, -2.0);
            offset[6] = vec2(-2.0,  2.0);
            offset[7] = vec2( 2.0,  2.0);
        }
        else if (params.x == Zoom_Scope)
        {
            offset[0] = vec2(-2.5,  0.0);
            offset[1] = vec2( 2.5,  0.0);
            offset[2] = vec2( 0.0, -2.5);
            offset[3] = vec2( 0.0,  2.5);
            offset[4] = vec2(-1.0, -1.0);
            offset[5] = vec2( 1.0, -1.0);
            offset[6] = vec2(-1.0,  1.0);
            offset[7] = vec2( 1.0,  1.0);
        }
        texcoord[0] = vtexcoord0;
        for (int i = 0; i < 8; i++)
        {
            texcoord[i+1] = vtexcoord0 + offset[i];
        }
    }
] [
    uniform vec4 params;
    uniform sampler2DRect tex0;
    uniform vec4 viewsize;
    varying vec2 texcoord[9];
    varying vec2 fragCoord;
    fragdata(0) vec4 fragcolor;

    const float weights[9] = float[]
    (
        0.260,
        0.055, 0.055, 0.055, 0.055,
        0.130, 0.130, 0.130, 0.130
    );

    float random(vec2 coord)
    {
        return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453);
    }

    void main(void)
    {
        const int Zoom_Sight = 1;
        const int Zoom_Scope = 2;
        if (params.x == Zoom_Sight)
        {
            vec2 screenCenter = viewsize.xy * 0.5;
            float radius = length(fragCoord - screenCenter) / length(viewsize.xy * 0.5);
            radius *= params.y;
            float vignette = (1.0 - smoothstep(0.6 * params.x, 1.0, radius));
            vec4 blurColor = vec4(0.0);
            for (int i = 0; i < 9; i++)
            {
                blurColor += weights[i] * texture2DRect(tex0, texcoord[i]);
            }
            vec4 originalColor = texture2DRect(tex0, fragCoord);
            float centerWeight = smoothstep(0.0, 0.6 * params.x, radius);
            fragcolor = mix(originalColor, blurColor, centerWeight) * vignette;
        }
        else if (params.x == Zoom_Scope)
        {
            vec2 screenCenter = viewsize.xy * 0.5;
            vec2 toCenter = fragCoord - screenCenter;
            float radius = length(toCenter) / length(viewsize.xy * 0.5);
            radius *= params.y;
            float vignette = 1.0 - smoothstep(0.1, 0.5, radius);
            float distortionStrength = smoothstep(0.2, 0.5, radius) * 0.2;
            vec2 distortedCoord = screenCenter + normalize(toCenter) * (1.0 + distortionStrength) * length(toCenter);
            float refractionStrength = mix(0.08, 0.3, smoothstep(0.1, 0.5, radius));
            float noiseFactor = (random(fragCoord) - 0.5) * 0.01;
            vec2 refractedCoord = mix(fragCoord, distortedCoord, smoothstep(0.2, 0.6, radius));
            refractedCoord += (toCenter * pow(radius, 2.0) * refractionStrength) + toCenter * noiseFactor;
            vec4 refractedColor = texture2DRect(tex0, refractedCoord);
            vec4 blurColor = vec4(0.0);
            for (int i = 0; i < 9; i++)
            {
                vec2 refCoord = texcoord[i] + (toCenter * pow(radius, 2.0) * refractionStrength) + toCenter * noiseFactor;
                blurColor += weights[i] * texture2DRect(tex0, refCoord);
            }
            vec4 originalColor = texture2DRect(tex0, refractedCoord);
            float centerWeight = smoothstep(0.0, 0.2, radius);
            vec4 finalColor = mix(originalColor, blurColor, centerWeight);
            fragcolor = mix(finalColor, refractedColor, 0.9) * vignette;
        }
    }
]

shader 0 "underwater" [
    attribute vec4 vvertex;
    uniform vec4 screentexcoord0;
    varying vec2 fragCoord;

    #define vtexcoord0 (vvertex.xy * screentexcoord0.xy + screentexcoord0.zw)

    void main(void)
    {
        gl_Position = vvertex;
        fragCoord = vtexcoord0;
    }
] [
    uniform vec4 params;
    uniform sampler2DRect tex0;
    uniform vec4 viewsize;
    varying vec2 fragCoord;
    fragdata(0) vec4 fragcolor;

    const vec2 offsets[9] = vec2[]
    (
        vec2(0.0,  0.0), vec2(-5.0, 0.0), vec2( 5.0,  0.0),
        vec2(0.0, -5.0), vec2( 0.0, 5.0), vec2(-3.5, -3.5),
        vec2(3.5, -3.5), vec2(-3.5, 3.5), vec2( 3.5,  3.5)
    );

    const float weights[9] = float[]
    (
        0.25,
        0.1, 0.1,
        0.1, 0.1,
        0.0875, 0.0875, 0.0875, 0.0875
    );

    float random(vec2 coord)
    {
        return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453);
    }

    void main(void)
    {
        vec2 screenCenter = viewsize.xy * 0.5;
        vec2 toCenter = fragCoord - screenCenter;
        float maxDist = length(viewsize.xy * 0.5);
        float radius = length(toCenter) / maxDist;
        float time = params.x / max(params.y, 1.0);
        vec2 wobbleOffset = vec2
        (
            sin(time * 10.0 + fragCoord.y * 0.05) * 5.0,
            cos(time * 8.0 + fragCoord.x * 0.05) * 5.0
        );
        vec2 distortedCoord = fragCoord + wobbleOffset;
        vec4 blurredColor = vec4(0.0);
        for (int i = 0; i < 9; i++)
        {
            blurredColor += weights[i] * texture2DRect(tex0, distortedCoord + offsets[i]);
        }
        fragcolor = blurredColor;
    }
]

shader 0 "fade_fromblack" [
    attribute vec4 vvertex;
    uniform vec4 screentexcoord0;
    varying vec2 fragCoord;

    #define vtexcoord0 (vvertex.xy * screentexcoord0.xy + screentexcoord0.zw)

    void main(void)
    {
        gl_Position = vvertex;
        fragCoord = vtexcoord0;
    }
] [
    uniform vec4 params;
    uniform sampler2DRect tex0;
    varying vec2 fragCoord;
    fragdata(0) vec4 fragcolor;

    void main(void)
    {
        vec4 scene = texture2DRect(tex0, fragCoord);
        float progress = clamp(params.x / max(params.y, 1.0), 0.0, 1.0);
        float direction = params.z >= 0 ? 1.0 - progress : progress;
        fragcolor = vec4(scene.rgb * direction, scene.a);
    }
]

shader 0 "evt_teleport" [
    attribute vec4 vvertex;
    uniform vec4 screentexcoord0;
    varying vec2 fragCoord;

    #define vtexcoord0 (vvertex.xy * screentexcoord0.xy + screentexcoord0.zw)

    void main(void)
    {
        gl_Position = vvertex;
        fragCoord = vtexcoord0;
    }
] [
    uniform vec4 params;
    uniform sampler2DRect tex0;
    uniform vec4 viewsize;
    varying vec2 fragCoord;
    fragdata(0) vec4 fragcolor;

    float random(vec2 coord)
    {
        return fract(sin(dot(coord.xy, vec2(26.9898, 78.233))) * 43758.5453);
    }

    void main(void)
    {
        vec2 screenCenter = viewsize.xy * 0.5;
        vec2 toCenter = fragCoord - screenCenter;
        float maxDist = length(viewsize.xy * 0.5);
        float radius = length(toCenter) / maxDist;
        float progress = clamp(params.x / max(params.y, 1.0), 0.0, 1.0);
        float direction = (params.z < 0) ? (1.0 - progress) : progress;
        float wobbleStrength = 15.0 * direction;
        float wobbleFrequency = 20.0;
        float randomX = random(fragCoord + params.x * 5.0) * 2.0 - 1.0;
        float randomY = random(fragCoord - params.x * 5.0) * 2.0 - 1.0;
        vec2 wobbleOffset = vec2
        (
            sin(params.x * wobbleFrequency + fragCoord.y * 0.1) * wobbleStrength + randomX * wobbleStrength,
            cos(params.x * wobbleFrequency + fragCoord.x * 0.1) * wobbleStrength + randomY * wobbleStrength
        );
        vec2 distortedCoord = fragCoord + wobbleOffset;
        vec4 scene = texture2DRect(tex0, distortedCoord);
        float whiteIntensity = mix(0.5, 1.0, direction);
        vec3 fadedColor = mix(scene.rgb, vec3(1.0) * whiteIntensity, direction);
        fragcolor = vec4(fadedColor, scene.a);
    }
]

shader 0 "evt_spawn" [
    attribute vec4 vvertex;
    uniform vec4 screentexcoord0;
    varying vec2 fragCoord;

    #define vtexcoord0 (vvertex.xy * screentexcoord0.xy + screentexcoord0.zw)

    void main(void)
    {
        gl_Position = vvertex;
        fragCoord = vtexcoord0;
    }
] [
    uniform vec4 params;
    uniform sampler2DRect tex0;
    uniform vec4 viewsize;
    varying vec2 fragCoord;
    fragdata(0) vec4 fragcolor;

    float random(vec2 coord)
    {
        return fract(sin(dot(coord.xy, vec2(26.9898, 78.233))) * 43758.5453);
    }

    vec3 saturate(vec3 color, float saturationLevel)
    {
        float luminance = dot(color, vec3(0.2126, 0.7152, 0.0722));
        return mix(vec3(luminance), color, saturationLevel);
    }

    void main(void)
    {
        vec2 screenCenter = viewsize.xy * 0.5;
        vec2 toCenter = fragCoord - screenCenter;
        float maxDist = length(viewsize.xy * 0.5);
        float radius = length(toCenter) / maxDist;
        float progress = clamp(params.x / max(params.y, 1.0), 0.0, 1.0);
        float direction = (params.z < 0.0) ? (1.0 - progress) : progress;
        float wobbleStrength = 10.0 * direction;
        float wobbleFrequency = 50.0;
        float randomX = random(fragCoord + params.x * 5.0) * 2.0 - 1.0;
        float randomY = random(fragCoord - params.x * 5.0) * 2.0 - 1.0;
        vec2 wobbleOffset = vec2
        (
            sin(params.x * wobbleFrequency + fragCoord.y * 0.1) * wobbleStrength + randomX * wobbleStrength,
            cos(params.x * wobbleFrequency + fragCoord.x * 0.1) * wobbleStrength + randomY * wobbleStrength
        );
        vec2 distortedCoord = clamp(fragCoord + wobbleOffset, vec2(0.0), viewsize.xy);
        vec4 scene = texture2DRect(tex0, distortedCoord);
        vec3 inverted = vec3(1.0) - scene.rgb;
        vec3 saturated = saturate(inverted, 2.0);
        float edge = length
        (
            texture2DRect(tex0, distortedCoord + vec2(1.0, 0.0)).rgb -
            texture2DRect(tex0, distortedCoord - vec2(1.0, 0.0)).rgb
        ) +
        length
        (
            texture2DRect(tex0, distortedCoord + vec2(0.0, 1.0)).rgb -
            texture2DRect(tex0, distortedCoord - vec2(0.0, 1.0)).rgb
        );
        edge = smoothstep(0.1, 0.4, edge) * direction;
        vec3 result = mix(scene.rgb, saturated, direction) * (1.0 - edge) + edge;
        fragcolor = vec4(result, scene.a);
    }
]

shader 0 "evt_pickup" [
    attribute vec4 vvertex;
    uniform vec4 screentexcoord0;
    varying vec2 fragCoord;

    #define vtexcoord0 (vvertex.xy * screentexcoord0.xy + screentexcoord0.zw)

    void main(void)
    {
        gl_Position = vvertex;
        fragCoord = vtexcoord0;
    }
] [
    uniform vec4 params;
    uniform sampler2DRect tex0;
    uniform vec4 viewsize;
    varying vec2 fragCoord;
    fragdata(0) vec4 fragcolor;

    void main(void)
    {
        vec4 scene = texture2DRect(tex0, fragCoord);
        vec2 screenCenter = viewsize.xy * 0.5;
        float maxDist = length(viewsize.xy * 0.5);
        float radius = length(fragCoord - screenCenter) / maxDist;
        float progress = clamp(params.x / max(params.y, 1.0), 0.0, 1.0);
        float vignetteRadius = mix(0.0, 1.0, progress);
        float fadeMultiplier = (params.z < 0) ? 1.5 : 1.0;
        float vignetteFade = (params.z < 0) ? (1.0 - progress) : progress;
        float vignetteSoftness = (params.z < 0) ? 0.35 : 0.5;
        float vignette = smoothstep(vignetteRadius - vignetteSoftness, vignetteRadius, radius);
        vec3 vignetteColor = vec3(1.0);
        float vignetteOpacity = 0.12 * fadeMultiplier;
        vec3 blendedColor = mix(scene.rgb, vignetteColor, vignette * vignetteFade * vignetteOpacity);
        fragcolor = vec4(blendedColor, scene.a);
    }
]
